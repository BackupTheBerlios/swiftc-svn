#include "fe/llvmfctdeclarer.h"

#include <llvm/Support/TypeBuilder.h>
#include <llvm/Module.h>

//#include "Packetizer/api.h"

#include "utils/cast.h"
#include "utils/llvmhelper.h"

#include "fe/context.h"
#include "fe/class.h"
#include "fe/node.h"
#include "fe/type.h"

namespace swift {

LLVMFctDeclarer::LLVMFctDeclarer(Context* ctxt)
    : ctxt_(ctxt)
{
    typedef Module::ClassMap::const_iterator CIter;
    const Module::ClassMap& classes = ctxt_->module_->classes();

    // for each class
    for (CIter iter = classes.begin(); iter != classes.end(); ++iter)
    {
        Class* c = iter->second;

        // skip builtin types
        if ( ScalarType::isScalar(c->id()) )
            continue;

        // for each member fct
        for (size_t i = 0; i < c->memberFcts().size(); ++i)
        {
            MemberFct* m = c->memberFcts()[i];

            if ( !m->isAutoGenerated() )
                process(c, m);
        }
    }

    llvm::Module* llvmModule = ctxt_->lmodule();
    llvm::LLVMContext& lctxt = llvmModule->getContext();

    /*
     * declare malloc
     */

    {
        const llvm::Type* retType = llvm::PointerType::getInt8PtrTy(lctxt);

        LLVMTypes params(1);
        params[0] = llvm::IntegerType::getInt64Ty(lctxt);

        const llvm::FunctionType* fctType = 
            llvm::FunctionType::get(retType, params, false);

        ctxt_->malloc_ = cast<llvm::Function>(
            llvmModule->getOrInsertFunction("malloc", fctType) );
        ctxt_->malloc_->addAttribute(0, llvm::Attribute::NoAlias);
        ctxt_->malloc_->addAttribute(~0, llvm::Attribute::NoUnwind);
    }

    /*
     * declare memcpy
     */

    {
        const llvm::Type* retType = createVoid(lctxt);
        LLVMTypes params(3);
        params[0] = llvm::PointerType::getInt8PtrTy(lctxt);
        params[1] = llvm::PointerType::getInt8PtrTy(lctxt);
        params[2] = llvm::IntegerType::getInt64Ty(lctxt);

        const llvm::FunctionType* fctType = 
            llvm::FunctionType::get(retType, params, false);

        ctxt_->memcpy_ = cast<llvm::Function>(
            llvmModule->getOrInsertFunction("memcpy", fctType) );
        ctxt_->memcpy_->addAttribute(1, llvm::Attribute::NoCapture);
        ctxt_->memcpy_->addAttribute(2, llvm::Attribute::NoCapture);
        ctxt_->memcpy_->addAttribute(~0, llvm::Attribute::NoUnwind);
    }
}

void LLVMFctDeclarer::process(Class* c, MemberFct* m)
{
    /*
     * get some stuff for easy access
     */

    TypeList&  in = m->sig_. inTypes_;
    TypeList& out = m->sig_.outTypes_;
    Module* module = ctxt_->module_;
    llvm::Module* llvmModule = ctxt_->lmodule();
    llvm::LLVMContext& lctxt = llvmModule->getContext();

    /*
     * is this the entry point?
     */

    if ( *m->id() == "main" 
            && m->sig_.in_.empty() 
            && !m->sig_.out_.empty() 
            && m->sig_.out_[0]->getType()->isInt()
            && dynamic_cast<Routine*>(m) )
    {
        m->main_ = true;
    }

    bool simd = m->isSimd();
    LLVMTypes simdParams;

    /*
     * create llvm function type
     */

    // push hidden 'self' param first if necessary
    if ( dynamic<Method>(m) )
    {
        m->params_.push_back( llvm::PointerType::getUnqual(c->getLLVMType()) );

        if (simd)
            simdParams.push_back( llvm::PointerType::getUnqual(c->getVecType()) );
    }

    const llvm::Type* simdRetType;

    // build return type
    if (m->main_)
    {
        m->retType_ = llvm::IntegerType::getInt32Ty(lctxt);
        m->realOut_.push_back( m->sig_.out_[0] );

        swiftAssert(!simd, "main routine may not be a simd routine");
    }
    else if ( out.empty() )
    {
        m->retType_ = createVoid(lctxt);

        if (simd)
            simdRetType = createVoid(lctxt);
    }
    else
    {
        LLVMTypes retTypes;
        LLVMTypes simdRetTypes;

        for (size_t i = 0; i < out.size(); ++i)
        {
            int simdLength;
            RetVal* retval = m->sig_.out_[i];
            const llvm::Type* llvmType = retval->getType()->getLLVMType(module);
            const llvm::Type* simdType; 
            if (simd)
                simdType = retval->getType()->getVecLLVMType(module, simdLength);

            if ( retval->getType()->perRef() )
            {
                m->params_.push_back(llvmType);
                m->realIn_.push_back(retval);

                if (simd)
                    simdParams.push_back(simdType);
            }
            else
            {
                retTypes.push_back(llvmType);
                m->realOut_.push_back(retval);

                if (simd)
                    simdRetTypes.push_back(simdType);
            }
        }

        if ( m->realOut_.empty() )
        {
            m->retType_ = createVoid(lctxt);

            if (simd)
                simdRetType = createVoid(lctxt);
        }
        else
        {
            m->retType_ = llvm::StructType::get(lctxt, retTypes);

            if (simd)
                simdRetType = llvm::StructType::get(lctxt, simdRetTypes);
        }
    }

    // now push the rest
    for (size_t i = 0; i < in.size(); ++i)
    {
        InOut* io = m->sig_.in_[i];
        m->params_.push_back(io->getType()->getLLVMType(module));
        m->realIn_.push_back(io);

        if (simd)
        {
            int simdLength;
            simdParams.push_back( io->getType()->getVecLLVMType(module, simdLength) );
        }
    }

    const llvm::FunctionType* fctType = llvm::FunctionType::get(
            m->retType_, m->params_, false);


    const llvm::FunctionType* simdFctType;

    if (simd)
        simdFctType = llvm::FunctionType::get(simdRetType, simdParams, false);

    /*
     * create function
     */

    std::string simdName;

    // create llvm name
    if (m->main_)
        m->setLLVMName("main");
    else
    {
        static int counter = 0;
        std::ostringstream oss;
        oss << c->cid() << '.' << m->cid() << counter++;
        m->setLLVMName( oss.str() );

        if (simd)
        {
            oss << ".simd";
            simdName = oss.str();
        }
    }

    llvm::Function* fct = cast<llvm::Function>( 
            llvmModule->getOrInsertFunction(m->getLLVMName().c_str(), fctType) );

    if (simd)
        m->simdFct_ = cast<llvm::Function>( llvmModule->getOrInsertFunction(simdName, simdFctType) );

    ctxt_->llvmFct_ = fct;
    m->llvmFct_     = fct;

    // set calling convention
    if (!m->main_)
    {
        fct->setCallingConv(llvm::CallingConv::Fast);

        if (simd)
            m->simdFct_->addFnAttr(llvm::Attribute::NoUnwind);
    }
    else
        fct->addFnAttr(llvm::Attribute::NoUnwind);

    // add noalias for all pointer args
    unsigned index = 1;
    llvm::Function::arg_iterator iter = fct->arg_begin();
    while ( iter != fct->arg_end() )
    {
        if ( dynamic<llvm::PointerType>(iter->getType()) )
        {
            fct->addAttribute(index, llvm::Attribute::NoAlias);

            if (simd)
                m->simdFct_->addAttribute(index, llvm::Attribute::NoAlias);
        }

        ++iter;
        ++index;
    }
}

} // namespace swift
