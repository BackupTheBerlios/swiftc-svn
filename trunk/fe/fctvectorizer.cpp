#include "fe/fctvectorizer.h"

#include <algorithm>

#include <llvm/Function.h>
#include <llvm/Intrinsics.h>
#include <llvm/Instructions.h>
#include <llvm/Module.h>
#include <llvm/PassManagers.h>
#include <llvm/Analysis/LoopInfo.h>
#include <llvm/Support/TypeBuilder.h>
#include <llvm/Transforms/Utils/FunctionUtils.h>

#include "Packetizer/api.h"

#include "vec/typevectorizer.h"

#include "utils/cast.h"

#include "fe/class.h"
#include "fe/context.h"
#include "fe/node.h"
#include "fe/scope.h"
#include "fe/type.h"


namespace swift {

StmntSimdLoopProcessor::StmntVisitor(Context* ctxt, Packetizer::Packetizer* packetizer)
    : StmntVisitorBase(ctxt)
    , packetizer_(packetizer)
{}

void StmntSimdLoopProcessor::visit(IfElStmnt* s)
{
    s->ifScope_->accept(this);

    if (s->elScope_)
        s->elScope_->accept(this);
}

void StmntSimdLoopProcessor::visit(RepeatUntilLoop* l)
{
    l->scope_->accept(this);
}

void StmntSimdLoopProcessor::visit(WhileLoop* l)
{
    l->scope_->accept(this);
}

void StmntSimdLoopProcessor::visit(SimdLoop* l)
{
    l->scope_->accept(this);

    llvm::BasicBlock* loopBB = l->loopBB_;

    // get all BBs belonging to l
    std::vector<llvm::BasicBlock*> bbs;
    enumBBs(l, loopBB, bbs);

    // calc dom-tree
    llvm::DominatorTree dt;
    dt.runOnFunction(*ctxt_->llvmFct_);

    // extract l's body to newFct
    llvm::Function* sFct = llvm::ExtractCodeRegion(dt, bbs);
    sFct->addAttribute(~0, llvm::Attribute::AlwaysInline);

    /*
     * get once a again the current loopBB since we now have a new one
     */
    llvm::BranchInst* branch = cast<llvm::BranchInst>( l->headerBB_->getTerminator() );
    swiftAssert(branch->getNumSuccessors() == 2, "must exactly return 2 succs");

    llvm::BasicBlock* outBB  = branch->getSuccessor(0);
    loopBB = branch->getSuccessor(1);

    // was this correct?
    if (outBB != l->outBB_)
        std::swap(outBB, loopBB);

    swiftAssert( outBB == l->outBB_, "must be the same BBs");
    l->loopBB_ = loopBB; // update new block

    /* 
     * find the index of the simd index
     */
    size_t index = 0;
    for (llvm::BasicBlock::iterator i = loopBB->begin(), e = loopBB->end(); i != e; ++i)
    {
        if ( llvm::CallInst* call = dynamic<llvm::CallInst>(&*i) )
        {
            size_t j = 0;
            for (llvm::CallInst::op_iterator i = call->op_begin(), e = call->op_end(); i != e; ++i)
            {
                if ( i->get() == static_cast<llvm::Value*>(l->index_->getAlloca()) )
                    index = j; // here we are

                ++j;
            }
        }
    }

    swiftAssert(index != 0, "must be found"); 
    // index = index - 1 + 1 (label vs return type)

    /*
     * packetize sFct
     */
    std::string scalarName = sFct->getNameStr();
    std::string simdName = scalarName + "_simd";

    int simdLength;
    const llvm::FunctionType* sFctType = sFct->getFunctionType();

    // set just the simdIndex param as uniform
    std::vector<bool> uniforms;
    uniforms.assign(sFctType->getNumParams()+1, false); // one for return type
    uniforms[index] = true;

    const llvm::FunctionType* vFctType = cast<llvm::FunctionType>(
            vec::vecFunctionType(ctxt_->lmodule(), Context::SIMD_WIDTH, sFctType, uniforms, simdLength) );

    std::cout << sFctType->getDescription() << std::endl;
    std::cout << vFctType->getDescription() << std::endl;

    ctxt_->lmodule()->getOrInsertFunction(simdName, vFctType);
    Packetizer::addFunctionToPacketizer(packetizer_, 4, scalarName, simdName); 
}

void StmntSimdLoopProcessor::enumBBs(SimdLoop* l, llvm::BasicBlock* bb, std::vector<llvm::BasicBlock*>& bbs)
{
    if (bb == l->epilogueBB_)
        return;

    if ( std::find(bbs.begin(), bbs.end(), bb) != bbs.end() )
        return;

    bbs.push_back(bb);

    for (llvm::succ_iterator iter = llvm::succ_begin(bb); iter != llvm::succ_end(bb); ++iter)
        enumBBs(l, *iter, bbs);
}

void StmntSimdLoopProcessor::visit(ScopeStmnt* s)
{
    s->scope_->accept(this);
}

//------------------------------------------------------------------------------

FctVectorizer::FctVectorizer(Context* ctxt)
    : ctxt_(ctxt)
    , packetizer_( Packetizer::getPacketizer(true, false) ) // TODO use cmdline switch for sse 4.1 selection
{
    typedef Module::ClassMap::const_iterator CIter;
    const Module::ClassMap& classes = ctxt_->module_->classes();

    // for each class
    for (CIter iter = classes.begin(); iter != classes.end(); ++iter)
    {
        Class* c = iter->second;

        // skip builtin types
        if ( ScalarType::isScalar(c->id()) )
            continue;

        // for each member fct
        for (size_t i = 0, end = c->memberFcts().size(); i < end; ++i)
        {
            MemberFct* m = c->memberFcts()[i];

            if ( m->isAutoGenerated() )
                continue;

            if ( m->isSimd() )
                processSimd(c, m);
            else
                processScalar(c, m);
        }
    }

    using namespace llvm::Intrinsic;
    const llvm::Type* llvmTypes[1];
    llvmTypes[0] = llvm::VectorType::get(
        llvm::TypeBuilder<llvm::types::ieee_float,  true>::get(ctxt_->lctxt()), 4); // HACK

    llvm::Function* powFct = getDeclaration(
            ctxt_->lmodule(), llvm::Intrinsic::pow, llvmTypes, 1);

    Packetizer::addNativeFunctionToPacketizer(
            packetizer_, "llvm.pow.f32", -1, powFct, false);

    Packetizer::runPacketizer( packetizer_, ctxt_->lmodule() );
}

void FctVectorizer::processSimd(Class* c, MemberFct* m)
{
    llvm::Function* fct = m->llvmFct();
    Packetizer::addFunctionToPacketizer(packetizer_, 4, fct->getNameStr(), m->simdFct()->getNameStr());
}

void FctVectorizer::processScalar(Class* c, MemberFct* m)
{
    StmntSimdLoopProcessor sslp(ctxt_, packetizer_);
    m->scope()->accept(&sslp);
}

} // namespace swift
