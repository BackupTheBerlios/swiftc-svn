#include "fe/fctvectorizer.h"

#include <algorithm>

#include <llvm/Function.h>
#include <llvm/Intrinsics.h>
#include <llvm/Instructions.h>
#include <llvm/PassManagers.h>
#include <llvm/Analysis/LoopInfo.h>
#include <llvm/Support/TypeBuilder.h>
#include <llvm/Transforms/Utils/FunctionUtils.h>

#include "utils/cast.h"

#include "fe/class.h"
#include "fe/context.h"
#include "fe/node.h"
#include "fe/scope.h"
#include "fe/type.h"

#include "Packetizer/api.h"

namespace swift {

StmntSimdLoopProcessor::StmntVisitor(Context* ctxt, Packetizer::Packetizer* packetizer)
    : StmntVisitorBase(ctxt)
    , packetizer_(packetizer)
{}

void StmntSimdLoopProcessor::visit(IfElStmnt* s)
{
    s->ifScope_->accept(this);

    if (s->elScope_)
        s->elScope_->accept(this);
}

void StmntSimdLoopProcessor::visit(RepeatUntilLoop* l)
{
    l->scope_->accept(this);
}

void StmntSimdLoopProcessor::visit(WhileLoop* l)
{
    l->scope_->accept(this);
}

void StmntSimdLoopProcessor::visit(SimdLoop* l)
{
    l->scope_->accept(this);

    //std::cout << l->headerBB_->getNameStr() << std::endl;

    llvm::BranchInst* branch = cast<llvm::BranchInst>( l->headerBB_->getTerminator() );
    swiftAssert(branch->getNumSuccessors() == 2, "must exactly return 2 succs");
    llvm::BasicBlock* outBB = branch->getSuccessor(0);
    llvm::BasicBlock* loopBB = branch->getSuccessor(1);

    // was this correct?
    if (outBB != l->outBB_)
        std::swap(outBB, loopBB);

    swiftAssert( outBB == l-> outBB_, "must be the same BBs");
    swiftAssert(loopBB == l->loopBB_, "must be the same BBs");

    // get all BBs belonging to l
    std::vector<llvm::BasicBlock*> bbs;
    enumBBs(l, loopBB, bbs);

    // calc dom-tree
    llvm::DominatorTree dt;
    dt.runOnFunction(*ctxt_->llvmFct_);

    // extract l's body to newFct
    llvm::Function* newFct = llvm::ExtractCodeRegion(dt, bbs);
    newFct->addAttribute(~0, llvm::Attribute::AlwaysInline);

    // packetize newFct
    std::string scalarName = newFct->getNameStr();
    std::string simdName = scalarName + "_simd";

    newFct->getType(); // TODO simdify

    Packetizer::addFunctionToPacketizer( packetizer_, 4, scalarName, simdName); 
}

void StmntSimdLoopProcessor::enumBBs(SimdLoop* l, llvm::BasicBlock* bb, std::vector<llvm::BasicBlock*>& bbs)
{
    if (bb == l->epilogueBB_)
        return;

    if ( std::find(bbs.begin(), bbs.end(), bb) != bbs.end() )
        return;

    bbs.push_back(bb);

    for (llvm::succ_iterator iter = llvm::succ_begin(bb); iter != llvm::succ_end(bb); ++iter)
        enumBBs(l, *iter, bbs);
}

void StmntSimdLoopProcessor::visit(ScopeStmnt* s)
{
    s->scope_->accept(this);
}

//------------------------------------------------------------------------------

FctVectorizer::FctVectorizer(Context* ctxt)
    : ctxt_(ctxt)
    , packetizer_( Packetizer::getPacketizer(true, false) ) // TODO use cmdline switch for sse 4.1 selection
{
    typedef Module::ClassMap::const_iterator CIter;
    const Module::ClassMap& classes = ctxt_->module_->classes();

    // for each class
    for (CIter iter = classes.begin(); iter != classes.end(); ++iter)
    {
        Class* c = iter->second;

        // skip builtin types
        if ( ScalarType::isScalar(c->id()) )
            continue;

        // for each member fct
        for (size_t i = 0, end = c->memberFcts().size(); i < end; ++i)
        {
            MemberFct* m = c->memberFcts()[i];

            if ( m->isAutoGenerated() )
                continue;

            if ( m->isSimd() )
                processSimd(c, m);
            else
                processScalar(c, m);
        }
    }

    using namespace llvm::Intrinsic;
    const llvm::Type* llvmTypes[1];
    llvmTypes[0] = llvm::VectorType::get(
        llvm::TypeBuilder<llvm::types::ieee_float,  true>::get(ctxt_->lctxt()), 4); // HACK

    llvm::Function* powFct = getDeclaration(
            ctxt_->lmodule(), llvm::Intrinsic::pow, llvmTypes, 1);

    Packetizer::addNativeFunctionToPacketizer(
            packetizer_, "llvm.pow.f32", -1, powFct, false);

    Packetizer::runPacketizer( packetizer_, ctxt_->lmodule() );
}

void FctVectorizer::processSimd(Class* c, MemberFct* m)
{
    llvm::Function* fct = m->llvmFct();
    Packetizer::addFunctionToPacketizer(packetizer_, 4, fct->getNameStr(), m->simdFct()->getNameStr());
}

void FctVectorizer::processScalar(Class* c, MemberFct* m)
{
    StmntSimdLoopProcessor sslp(ctxt_, packetizer_);
    m->scope()->accept(&sslp);
}

} // namespace swift
